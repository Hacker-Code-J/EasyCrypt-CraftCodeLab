require import AllCore List Distr.

(* Types for K, P, N, respectively *)
type key, ptxt, nonce.

(* Type for C *)
type ctxt = ptxt.

(* Binary infix operator on P *)
op (+) : ptxt -> ptxt -> ptxt.

(* Family of functions N -> P, indexed by k *)
op f : key -> nonce -> ptxt.

(* Sub-distribution over keys *)
op dkey : key distr.

(* Associativity, Commutativity, and
  "self-inverse" property of the binary operator,
  respectively *)
axiom addpA (x y z : ptxt) : (x + y) + z = x + (y + z).
axiom addpC (x y : ptxt) : x + y = y + x.
axiom addKp (x y : ptxt) : x + x + y = y.

module type NBEncScheme = {
  proc kgen(): key
  proc enc(k: key, n : nonce, m : ptxt): ctxt
  proc dec(k: key, n : nonce, c : ctxt): ptxt
}.

module E : NBEncScheme = {
  proc kgen() : key = {
    var k;
    k <$ dkey;
    return k;
  }

  proc enc(k : key, n : nonce, m : ptxt) : ctxt = {
    return (f k n) + m;
  }

  proc dec(k : key, n : nonce, c : ctxt) : ptxt = {
    return (f k n) + c;
  }
}.

module type NRCPA_Oraclei = {
  proc init() : unit
  proc enc(n : nonce, m : ptxt) : ctxt option
}.

module O_NRCPA_real (S : NBEncScheme) : NRCPA_Oraclei = {
  var k : key
  var log : nonce list

  proc init() : unit = {
    k <@ S.kgen();
    log <- [];
  }

  proc enc(n : nonce, m : ptxt) : ctxt option = {
    var c : ctxt;
    var r : ctxt option;

    if (! (n \in log)) {
      log <- n :: log;

      c <@ S.enc(k, n, m);

      r <- Some c;
    } else {
      r <- None;
    }
    
    return r;
  }
}.

op [lossless full uniform] dctxt : ctxt distr.
 
module O_NRCPA_ideal : NRCPA_Oraclei = {
  var log : nonce list
  
  proc init() : unit = {
    log <- [];
  }

  proc enc(n : nonce, m : ptxt) : ctxt option = {
    var c : ctxt;
    var r : ctxt option;

    if (! (n \in log)) {
      log <- n :: log;
      
      c <$ dctxt;

      r <- Some c;
    } else {
      r <- None;
    }
    
    return r;
  }
}.

module type NRCPA_Oracle = {
  include NRCPA_Oraclei [enc]
}.

module type Adv_IND_NRCPA (O : NRCPA_Oracle) = {
  proc distinguish() : bool
}.

module Exp_IND_NRCPA (O : NRCPA_Oraclei) (D : Adv_IND_NRCPA) = {
  proc run() : bool = {
    var b : bool;

    O.init();

    b <@ D(O).distinguish();

    return b;
  }
}.

module type NRPRF_Oraclei = {
  proc init() : unit
  proc get(n : nonce) : ptxt option
}.

module O_NRPRF_real : NRPRF_Oraclei = {
  var k : key
  var log : nonce list

  proc init() : unit = {
    k <$ dkey;
    log <- [];
  }

  proc get(n : nonce) : ptxt option = {
    var r : ptxt option;

    if (! (n \in log)) {
      log <- n :: log;
      r <- Some (f k n);
    } else {
      r <- None;
    }

    return r;
  }
}.

op dptxt : ptxt distr = dctxt.

module O_NRPRF_ideal : NRPRF_Oraclei = {
  var log : nonce list

  proc init() : unit = {
    log <- [];
  }

  proc get(n : nonce) : ptxt option = {
    var y : ptxt;
    var r : ptxt option;

    if (! (n \in log)) {
      log <- n :: log;

      y <$ dptxt;
      
      r <- Some y;
    } else {
      r <- None;
    }

    return r;
  }
}.

module type NRPRF_Oracle = {
  include NRPRF_Oraclei [get]
}.

module type Adv_NRPRF (O : NRPRF_Oracle) = {
  proc distinguish() : bool
}.

module Exp_NRPRF (O : NRPRF_Oraclei) (D : Adv_NRPRF) = {
  proc run() : bool = {
    var b : bool;

    O.init();

    b <@ D(O).distinguish();

    return b;
  }
}.

(*lemma EqAdvantage_IND_NRCPA_NRPRF &m:
  `| Pr[Exp_IND_NRCPA(O_NRCPA_real(E), D).run() @ &m: res]
    - Pr[Exp_IND_NRCPA(O_NRCPA_ideal, D).run() @ &m: res] |
  =
  `| Pr[Exp_NRPRF(O_NRPRF_real, R_NRPRF_IND_NRCPA(D)).run() @ &m: res]
    - Pr[Exp_NRPRF(O_NRPRF_ideal, R_NRPRF_IND_NRCPA(D)).run() @ &m: res] |.*)